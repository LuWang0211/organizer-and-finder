import type { UIScene } from "@phaser/UIScene";
import { startCoroutine } from "@/utils/coroutine";

type Rectangle = {
  width: number;
  height: number;
  x?: number;
  y?: number;
  data: number;
};

// This function is generated by ChatGPT4o
function* distributeRectangles(W: number, H: number, rectangles: Rectangle[]) {
  // Helper function to check for overlap between two rectangles
  function isOverlapping(rect1: Rectangle, rect2: Rectangle): boolean {
    return !(
      rect1.x! + rect1.width <= rect2.x! ||
      rect2.x! + rect2.width <= rect1.x! ||
      rect1.y! + rect1.height <= rect2.y! ||
      rect2.y! + rect2.height <= rect1.y!
    );
  }

  // Helper function to generate a random position within the region
  function getRandomPosition(
    rectWidth: number,
    rectHeight: number,
  ): { x: number; y: number } {
    const x = Math.random() * (W - rectWidth);
    const y = Math.random() * (H - rectHeight);
    return { x, y };
  }

  const placedRectangles: Rectangle[] = [];

  // Attempt to place each rectangle
  for (const rect of rectangles) {
    let placed = false;
    let attempts = 0;
    while (!placed && attempts < 100) {
      // limit attempts to avoid infinite loop
      attempts++;
      const position = getRandomPosition(rect.width, rect.height);
      const newRect: Rectangle = {
        ...rect,
        x: position.x,
        y: position.y,
      };

      // Check for overlap with already placed rectangles
      let overlap = false;
      for (const placedRect of placedRectangles) {
        if (isOverlapping(newRect, placedRect)) {
          overlap = true;
          break;
        }
      }

      if (!overlap) {
        placedRectangles.push(newRect);

        yield newRect;
        placed = true;
      }
    }

    if (!placed) {
      console.error(
        `Could not place rectangle with width ${rect.width} and height ${rect.height}`,
      );
    }
  }
}

export class SketchBackground {
  private scene: UIScene;
  private glyphs: Phaser.GameObjects.Image[];

  constructor(scene: UIScene) {
    this.scene = scene;
    this.glyphs = [];

    this.create();
  }

  create() {
    const viewportWidth = this.scene.scale.width;

    if (viewportWidth < 800) {
      this.createBackgroundForMobile();
    } else {
      this.createBackgroundForDesktop();
    }
  }

  private createBackgroundForMobile() {
    const viewportWidth = this.scene.scale.width;

    const glyph = this.scene.add.image(viewportWidth / 2, 0, "Blueprint1");

    glyph.y = glyph.height / 2;
  }

  private createBackgroundForDesktop() {
    const glyphs = [
      "Blueprint1",
      "Blueprint2",
      "Blueprint3",
      "Blueprint4",
      "BPICON1",
      "BPICON2",
      "BPICON3",
      "BPICON3",
    ];

    this.glyphs = glyphs.map((glyphTexture) => {
      const glyph = this.scene.add.image(0, 0, glyphTexture);
      glyph.visible = false;
      return glyph;
    });

    const rectangles: Rectangle[] = this.glyphs.map((glyph, index) => {
      return { width: glyph.width, height: glyph.height, data: index };
    });

    const viewportWidth = this.scene.scale.width;
    const viewportHeight = this.scene.scale.height;

    const instance = this;

    startCoroutine(this.scene, function* () {
      const placedRectangles = distributeRectangles(
        viewportWidth,
        viewportHeight,
        rectangles,
      );
      for (const rect of placedRectangles) {
        const { x, y, data } = rect;
        const glyph = instance.glyphs[data];

        glyph.setPosition(x! + glyph.width / 2, y! + glyph.height / 2);
        glyph.visible = true;
        glyph.alpha = 0;

        instance.scene.tweens.add({
          targets: glyph,
          alpha: 1,
          duration: 1000,
          ease: "quart.out",
          persist: false,
        });

        yield rect;
      }
    });
  }
}
